//=+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=
// HashTable_LinkedList
//=+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=+=+==+=
// Name        : HashTable.cpp
// Completed by: Janet Mardjuki
// Description : Implementation File for Hash Table
//==========================================================================================================================
#include "HashTable.h"
#include <string>
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//===========================================   DEFAULT CONSTRUCTOR  =======================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Default Constructor
//==========================================================================================================================
// Create a default sized hash table
//	// PRE: N/A
//	// POST: Create a hash table of size 101. Set the arraySize to 101. Set the number item as 0 (empty)
//	// PARAM: N/A
//==========================================================================================================================
HashTable::HashTable(void)
{
	arraySize = 101;
	arr = new LinkedList[arraySize];
	numberItem = 0;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//================================================   CONSTRUCTOR  ==========================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Constructor
//==========================================================================================================================
// Create a hash table with the specified size
//	// PRE: n cannot be negative
//	// POST: Create a hash table of size ~2n (prime number nearest to 2n). Set the arraySize to ~2n. Set the number item as 0 (empty)
//	// PARAM: N/A
//========================================================================================================================== 
HashTable::HashTable(int n)
{
	bool isPrime = false;
	n = 2*n;
	while( !isPrime)
	{
		n++;
		isPrime = isItPrime(n);
	}
	arraySize = n;
	arr = new LinkedList[arraySize];
	numberItem = 0;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//============================================   COPY CONSTRUCTOR  ========================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Copy Constructor
//==========================================================================================================================
// Create a new hashtable with a deep copy of the parameter hash table
//	// PRE: N/A
//	// POST: Deep copy the hash table parameter and create a new hash table with that contents
//	// PARAM: toCopy is the reference parameter pointing the hashtable that user wanted to copy
//==========================================================================================================================
HashTable::HashTable(const HashTable &toCopy)
{
	// Copy the attrivbutes associated with the parameter
	arraySize = toCopy.arraySize;
	numberItem = toCopy.numberItem;

	// Create a new dynamic array with the appropriate attributes 
	arr = new LinkedList[arraySize];

	// Copy all the the contents of the parameter array to the new array just created
	for(int i = 0;  i < arraySize; i++)
	{
		arr[i] = (toCopy.arr[i]);
	}

}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//============================================ ASSIGNMENT OPERATOR =  ======================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Assignment Operator =
//==========================================================================================================================
// Assign the operator '=' so it will deep copy the hashtable parameter to 'this'
//	// PRE: N/A
//	// POST: If the calling hashtable is not the parameter 
//		   : -> De-allocate all the memory associated with the calling hashtable
//		   : -> Deep copy the contents of hashtable parameter and put in the calling hashtable.
//		   : -> Return the calling object
//	// PARAM: toBeCopied is the hashtable that program will copy
//==========================================================================================================================
HashTable &HashTable::operator= (const HashTable &toBeCopied)
{
	// Only copy is the calling object is not the equal to the parameter
	if(&toBeCopied != this)
	{
		delete [] arr;

		// Copy the parameter attributes
		arraySize = toBeCopied.arraySize;
		numberItem = toBeCopied.numberItem;

		// Create a new dynamic array with the appropriate attributes 
		arr = new LinkedList[arraySize];

		// Copy all the the contents of the parameter array to the new array just created
		for(int i = 0;  i < toBeCopied.arraySize; i++)
		{
			arr[i] = toBeCopied.arr[i];
		}
	}
	return *this;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//================================================== Is It Prime ===========================================================
//=========================================== (Helper for [Constructor])  ==================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Is It Prime
//==========================================================================================================================
// Check if the parameter number is a prime number
//	// PRE: n cannot be negative
//	// POST: Check if the parameter is a prime number
//	// PARAM: n is the number to be check
//==========================================================================================================================
bool HashTable::isItPrime(int n) const
{
	// 1 and 0 are not a prime number
	if( n == 1 || n == 0)
	{
		return false;
	}

	//Only check until i^2, else not prime
	for(int i = 2; i*i <= n; i++)
	{
		// Can be divided by other than itself
		if( (n%i) == 0)
		{
			return false;
		}
	}
	return true;

}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//================================================== Destructor ============================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Destructor
//==========================================================================================================================
// De-allocate all the memory associated with the calling hash table
//	// PRE: N/A
//	// POST: De-allocate all the memory associated with the calling hash table
//	// PARAM: N/A
//==========================================================================================================================
HashTable::~HashTable(void)
{
	delete [] arr;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//=====================================================   INSERT  ==========================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Insert
//==========================================================================================================================
// Insert item to the hash table
//	// PRE: N/A
//	// POST: Insert item to the hash table index that determined by the hash function. Return true if it's succesfully inserted; false otherwise
//	// PARAM: toInsert is the string to be inserted
//==========================================================================================================================
bool HashTable::insert (string toInsert)
{
	// Gotta use the hashfunction to find the table's index
	int indexNum = hashFunction(toInsert);
	// Use Linked Lits's Insert function on that linked list at that index in hash table
	bool success = arr[indexNum].insert(toInsert);
	// If succesfully inserted
	if(success)
	{
		// Increse the number of item
		numberItem++;
		return true;
	}
	return false;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//=====================================================   REMOVE  ==========================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Remove
//==========================================================================================================================
// Remove item from the hash table
//	// PRE: N/A
//	// POST: Remove item from the hash table index that determined by the hash function. Return true if it's succesfully removed; false otherwise
//	// PARAM: toRemove is the string to be inserted
//==========================================================================================================================
bool HashTable::remove(string toRemove)
{
	// Gotta use the hashfunction to find the table's index
	int indexNum = hashFunction(toRemove);
	// Use Linked Lits's Remove function on that linked list at that index in hash table
	bool success = arr[indexNum].remove(toRemove);
	// If succesfully removed
	if(success)
	{
		// Remove the number of item
		numberItem--;
		return true;
	}
	return false;

}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//=================================================   SEARCH  ==============================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Search
//==========================================================================================================================
// Check if item exist in the hash table
//	// PRE: N/A
//	// POST: Search item in the hash table. Return true if it's faound in table; false otherwise
//	// PARAM: toRemove is the string to be inserted
//==========================================================================================================================
bool HashTable::search(string toSearch) const
{
	// Gotta use the hashfunction to find the table's index
	int indexNum = hashFunction(toSearch);
	// Use Linked Lits's Search function on that linked list at that index in hash table
	return arr[indexNum].search(toSearch);
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//================================================ Hash Function ===========================================================
//================================= (Helper for [Insert] & [Remove] & [Search])  ===========================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Hash Function
//==========================================================================================================================
// Calculate the index of where it has to put the string
//	// PRE: N/A
//	// POST: Returns the index of the where string should be
//	// PARAM: toInsert is the string to be find the index number at the table
//==========================================================================================================================
int HashTable::hashFunction(string toInsert) const
{
	int ascii = 0;						// ASCII number storage
	int total = 0;						// For the total sum (index)
	int deductor = 1;					// 1 Less that the current
	int lengthOfWord = toInsert.size();	// String's lenght
	for(int i =0; i < lengthOfWord ; i++)
	{
		ascii =  toInsert[i] - 96;											// Get the ASCII number
		total = total + (ascii * (pow(32.0 , lengthOfWord-deductor)));		// Total it up
		total = (total%arraySize);											// Honer's method
		deductor++;

	}
	return total;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//==================================================   SIZE  ===============================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Size
//==========================================================================================================================
// Get the number of item in the table
//	// PRE: N/A
//	// POST: Return the number of item in the table
//	// PARAM: N/A
//==========================================================================================================================
int HashTable::size() const
{
	 return numberItem;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//================================================   MAX SIZE  =============================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Max Size
//==========================================================================================================================
// Get the table size
//	// PRE: N/A
//	// POST: Return the size of the table (array)
//	// PARAM: N/A
//==========================================================================================================================
int HashTable::maxSize() const
{
	 return arraySize;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//=============================================   LOAD FACTOR  =============================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Load Factor
//==========================================================================================================================
// Get load factor of the table
//	// PRE: N/A
//	// POST: Return the load factor of the table
//	// PARAM: N/A
//==========================================================================================================================
double HashTable::loadFactor() const
{
	// Load factor = number of items / table size
	return numberItem / arraySize;
}


//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//==============================================   INTERSECTION   ==========================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Intersection
//==========================================================================================================================
// Get the intersection of the the calling hash table and the parameter hash table
//	// PRE: N/A
//	// POST: Returns vector that contains the intersection of the calling hash table and the parameter hash table
//	// PARAM: N/A
//==========================================================================================================================
vector<string> HashTable::intersection(const HashTable &theSecond) const
{
	vector<string> vIntersection;		// Vector to store the intersection
	vector<string> vTemp;				// Temporary vector to store the current Linked List
	// For all the linked list in the calling hash table
	for(int i = 0; i <arraySize; i++)
	{
		// Get the vector of the current linked list
		vTemp = arr[i].get();
		// For the all the element in the vector
		for(int j = 0; j < vTemp.size(); j++)
		{
			// Check if it present in parameter hash table
			if(theSecond.search(vTemp[j]) )
			{
				// If yes push the current element in the intersection vector
				vIntersection.push_back(vTemp[j]);
			}
		}
	}
	return vIntersection;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//==================================================   UNION  ==============================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Union
//==========================================================================================================================
// Get the union of the the calling hash table and the parameter hash table
//	// PRE: N/A
//	// POST: Returns vector that contains the union of the calling hash table and the parameter hash table
//	// PARAM: N/A
//==========================================================================================================================
vector<string> HashTable::unions(const HashTable &theSecond) const
{
	vector<string> vUnion;		// Vector to store the union
	vector<string> vTemp;		// Temporary vector to store the current Linked List
	// For all the linked list in the parameter hash table
	for(int i = 0; i < theSecond.arraySize; i++)
	{
		// Get the vector of the current linked list (parameter hash table)
		vTemp = theSecond.arr[i].get();
		// For the all the element in the vector
		for(int j = 0; j < vTemp.size(); j++)
		{
			// If yes push the current element in the union vector
			vUnion.push_back(vTemp[j]);
		}
	}
	// For all the linked list in the calling hash table
	for(int i = 0; i < arraySize; i++)
	{
		// Get the vector of the current linked list (calling hash table)
		vTemp = arr[i].get();
		// For the all the element in the vector
		for(int j = 0; j < vTemp.size(); j++)
		{
			// Check if it not present in parameter hash table
			if(! theSecond.search(vTemp[j]) )
			{
				// If yes push the current element in the union vector
				vUnion.push_back(vTemp[j]);
			}
		}
	}

	return vUnion;
}

//==========================================================================================================================
//--------------------------------------------------------------------------------------------------------------------------
//=============================================   DIFFERENCE  ==============================================================
//--------------------------------------------------------------------------------------------------------------------------
//==========================================================================================================================
//
//==========================================================================================================================
// Differnce 
//==========================================================================================================================
// Get the difference of the the calling hash table and the parameter hash table
//	// PRE: N/A
//	// POST: Returns vector that contains the fiffernce of the calling hash table and the parameter hash table
//	// PARAM: N/A
//==========================================================================================================================
vector<string> HashTable::difference(const HashTable &theSecond) const
{
	vector<string> vDifference;		// Vector to store the differnce
	vector<string> vTemp;			// Temporary vector to store the current Linked List
	// For all the linked list in the calling hash table
	for(int i = 0; i < arraySize; i++)
	{
		// Get the vector of the current linked list (calling hash table)
		vTemp = arr[i].get();
		// For the all the element in the vector
		for(int j = 0; j < vTemp.size(); j++)
		{
			// Check if it not present in parameter hash table
			if(!theSecond.search(vTemp[j]) )
			{
				// If yes push the current element in the union vector
				vDifference.push_back(vTemp[j]);
			}
		}
	}

	return vDifference;

}
